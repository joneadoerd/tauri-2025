// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: packet.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "packet";

export interface Packet {
  header?: PacketHeader | undefined;
  payload?: PacketPayload | undefined;
  checksum?: PacketChecksum | undefined;
  timestamp?: PacketTimestamp | undefined;
  source?: PacketSource | undefined;
  destination?: PacketDestination | undefined;
  protocol?: PacketProtocol | undefined;
  flags?: PacketFlags | undefined;
  version?: PacketVersion | undefined;
  target_packet?: TargetPacket | undefined;
  target_packet_list?:
    | TargetPacketList
    | undefined;
  /** Delimiter to indicate end of packet */
  delimiter: number;
}

export interface PacketHeader {
  id: number;
  length: number;
  checksum: number;
  version: number;
  flags: number;
}

export interface PacketPayload {
  typeValue: number;
  data: Uint8Array;
  size: number;
  encoding: string;
}

export interface PacketChecksum {
  algorithm: number;
  value: Uint8Array;
  length: number;
}

export interface PacketTimestamp {
  seconds: number;
  nanoseconds: number;
}

export interface PacketSource {
  ip: string;
  port: number;
  mac: string;
}

export interface PacketDestination {
  ip: string;
  port: number;
  mac: string;
}

export interface PacketProtocol {
  name: string;
  version: number;
  description: string;
}

export interface PacketFlags {
  is_fragmented: boolean;
  is_encrypted: boolean;
  is_compressed: boolean;
  is_signed: boolean;
}

export interface PacketVersion {
  major: number;
  minor: number;
  patch: number;
  build: string;
}

export interface PacketError {
  code: number;
  message: string;
  details: string;
}

export interface PacketStatus {
  code: number;
  message: string;
  details: string;
}

export interface PacketResponse {
  code: number;
  message: string;
  data: Uint8Array;
  error: PacketError | undefined;
  status: PacketStatus | undefined;
}

export interface PacketRequest {
  id: number;
  method: string;
  params: Uint8Array;
  error: PacketError | undefined;
  status: PacketStatus | undefined;
}

export interface PacketAck {
  id: number;
  message: string;
  data: Uint8Array;
  error: PacketError | undefined;
  status: PacketStatus | undefined;
}

export interface PacketNack {
  id: number;
  message: string;
  data: Uint8Array;
  error: PacketError | undefined;
  status: PacketStatus | undefined;
}

export interface PacketPing {
  id: number;
  message: string;
  data: Uint8Array;
  error: PacketError | undefined;
  status: PacketStatus | undefined;
}

export interface SerialPacketEvent {
  id: string;
  packet: Packet | undefined;
}

export interface TargetPacket {
  target_id: number;
  lat: number;
  lon: number;
  alt: number;
  time: number;
}

export interface TargetPacketList {
  packets: TargetPacket[];
}

function createBasePacket(): Packet {
  return {
    header: undefined,
    payload: undefined,
    checksum: undefined,
    timestamp: undefined,
    source: undefined,
    destination: undefined,
    protocol: undefined,
    flags: undefined,
    version: undefined,
    target_packet: undefined,
    target_packet_list: undefined,
    delimiter: 0,
  };
}

export const Packet: MessageFns<Packet> = {
  encode(message: Packet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      PacketHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.payload !== undefined) {
      PacketPayload.encode(message.payload, writer.uint32(18).fork()).join();
    }
    if (message.checksum !== undefined) {
      PacketChecksum.encode(message.checksum, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== undefined) {
      PacketTimestamp.encode(message.timestamp, writer.uint32(34).fork()).join();
    }
    if (message.source !== undefined) {
      PacketSource.encode(message.source, writer.uint32(42).fork()).join();
    }
    if (message.destination !== undefined) {
      PacketDestination.encode(message.destination, writer.uint32(50).fork()).join();
    }
    if (message.protocol !== undefined) {
      PacketProtocol.encode(message.protocol, writer.uint32(58).fork()).join();
    }
    if (message.flags !== undefined) {
      PacketFlags.encode(message.flags, writer.uint32(66).fork()).join();
    }
    if (message.version !== undefined) {
      PacketVersion.encode(message.version, writer.uint32(74).fork()).join();
    }
    if (message.target_packet !== undefined) {
      TargetPacket.encode(message.target_packet, writer.uint32(82).fork()).join();
    }
    if (message.target_packet_list !== undefined) {
      TargetPacketList.encode(message.target_packet_list, writer.uint32(90).fork()).join();
    }
    if (message.delimiter !== 0) {
      writer.uint32(101).fixed32(message.delimiter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Packet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = PacketHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = PacketPayload.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checksum = PacketChecksum.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = PacketTimestamp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = PacketSource.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destination = PacketDestination.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.protocol = PacketProtocol.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.flags = PacketFlags.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.version = PacketVersion.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.target_packet = TargetPacket.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.target_packet_list = TargetPacketList.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 101) {
            break;
          }

          message.delimiter = reader.fixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Packet {
    return {
      header: isSet(object.header) ? PacketHeader.fromJSON(object.header) : undefined,
      payload: isSet(object.payload) ? PacketPayload.fromJSON(object.payload) : undefined,
      checksum: isSet(object.checksum) ? PacketChecksum.fromJSON(object.checksum) : undefined,
      timestamp: isSet(object.timestamp) ? PacketTimestamp.fromJSON(object.timestamp) : undefined,
      source: isSet(object.source) ? PacketSource.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? PacketDestination.fromJSON(object.destination) : undefined,
      protocol: isSet(object.protocol) ? PacketProtocol.fromJSON(object.protocol) : undefined,
      flags: isSet(object.flags) ? PacketFlags.fromJSON(object.flags) : undefined,
      version: isSet(object.version) ? PacketVersion.fromJSON(object.version) : undefined,
      target_packet: isSet(object.target_packet) ? TargetPacket.fromJSON(object.target_packet) : undefined,
      target_packet_list: isSet(object.target_packet_list)
        ? TargetPacketList.fromJSON(object.target_packet_list)
        : undefined,
      delimiter: isSet(object.delimiter) ? globalThis.Number(object.delimiter) : 0,
    };
  },

  toJSON(message: Packet): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = PacketHeader.toJSON(message.header);
    }
    if (message.payload !== undefined) {
      obj.payload = PacketPayload.toJSON(message.payload);
    }
    if (message.checksum !== undefined) {
      obj.checksum = PacketChecksum.toJSON(message.checksum);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = PacketTimestamp.toJSON(message.timestamp);
    }
    if (message.source !== undefined) {
      obj.source = PacketSource.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = PacketDestination.toJSON(message.destination);
    }
    if (message.protocol !== undefined) {
      obj.protocol = PacketProtocol.toJSON(message.protocol);
    }
    if (message.flags !== undefined) {
      obj.flags = PacketFlags.toJSON(message.flags);
    }
    if (message.version !== undefined) {
      obj.version = PacketVersion.toJSON(message.version);
    }
    if (message.target_packet !== undefined) {
      obj.target_packet = TargetPacket.toJSON(message.target_packet);
    }
    if (message.target_packet_list !== undefined) {
      obj.target_packet_list = TargetPacketList.toJSON(message.target_packet_list);
    }
    if (message.delimiter !== 0) {
      obj.delimiter = Math.round(message.delimiter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Packet>, I>>(base?: I): Packet {
    return Packet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Packet>, I>>(object: I): Packet {
    const message = createBasePacket();
    message.header = (object.header !== undefined && object.header !== null)
      ? PacketHeader.fromPartial(object.header)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? PacketPayload.fromPartial(object.payload)
      : undefined;
    message.checksum = (object.checksum !== undefined && object.checksum !== null)
      ? PacketChecksum.fromPartial(object.checksum)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? PacketTimestamp.fromPartial(object.timestamp)
      : undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? PacketSource.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? PacketDestination.fromPartial(object.destination)
      : undefined;
    message.protocol = (object.protocol !== undefined && object.protocol !== null)
      ? PacketProtocol.fromPartial(object.protocol)
      : undefined;
    message.flags = (object.flags !== undefined && object.flags !== null)
      ? PacketFlags.fromPartial(object.flags)
      : undefined;
    message.version = (object.version !== undefined && object.version !== null)
      ? PacketVersion.fromPartial(object.version)
      : undefined;
    message.target_packet = (object.target_packet !== undefined && object.target_packet !== null)
      ? TargetPacket.fromPartial(object.target_packet)
      : undefined;
    message.target_packet_list = (object.target_packet_list !== undefined && object.target_packet_list !== null)
      ? TargetPacketList.fromPartial(object.target_packet_list)
      : undefined;
    message.delimiter = object.delimiter ?? 0;
    return message;
  },
};

function createBasePacketHeader(): PacketHeader {
  return { id: 0, length: 0, checksum: 0, version: 0, flags: 0 };
}

export const PacketHeader: MessageFns<PacketHeader> = {
  encode(message: PacketHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.length !== 0) {
      writer.uint32(16).uint32(message.length);
    }
    if (message.checksum !== 0) {
      writer.uint32(24).uint32(message.checksum);
    }
    if (message.version !== 0) {
      writer.uint32(32).uint32(message.version);
    }
    if (message.flags !== 0) {
      writer.uint32(40).uint32(message.flags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.length = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.checksum = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.flags = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketHeader {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      checksum: isSet(object.checksum) ? globalThis.Number(object.checksum) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      flags: isSet(object.flags) ? globalThis.Number(object.flags) : 0,
    };
  },

  toJSON(message: PacketHeader): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.checksum !== 0) {
      obj.checksum = Math.round(message.checksum);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.flags !== 0) {
      obj.flags = Math.round(message.flags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketHeader>, I>>(base?: I): PacketHeader {
    return PacketHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketHeader>, I>>(object: I): PacketHeader {
    const message = createBasePacketHeader();
    message.id = object.id ?? 0;
    message.length = object.length ?? 0;
    message.checksum = object.checksum ?? 0;
    message.version = object.version ?? 0;
    message.flags = object.flags ?? 0;
    return message;
  },
};

function createBasePacketPayload(): PacketPayload {
  return { typeValue: 0, data: new Uint8Array(0), size: 0, encoding: "" };
}

export const PacketPayload: MessageFns<PacketPayload> = {
  encode(message: PacketPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeValue !== 0) {
      writer.uint32(8).uint32(message.typeValue);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.size !== 0) {
      writer.uint32(24).uint32(message.size);
    }
    if (message.encoding !== "") {
      writer.uint32(34).string(message.encoding);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.typeValue = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encoding = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketPayload {
    return {
      typeValue: isSet(object.typeValue) ? globalThis.Number(object.typeValue) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
    };
  },

  toJSON(message: PacketPayload): unknown {
    const obj: any = {};
    if (message.typeValue !== 0) {
      obj.typeValue = Math.round(message.typeValue);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.encoding !== "") {
      obj.encoding = message.encoding;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketPayload>, I>>(base?: I): PacketPayload {
    return PacketPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketPayload>, I>>(object: I): PacketPayload {
    const message = createBasePacketPayload();
    message.typeValue = object.typeValue ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.size = object.size ?? 0;
    message.encoding = object.encoding ?? "";
    return message;
  },
};

function createBasePacketChecksum(): PacketChecksum {
  return { algorithm: 0, value: new Uint8Array(0), length: 0 };
}

export const PacketChecksum: MessageFns<PacketChecksum> = {
  encode(message: PacketChecksum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== 0) {
      writer.uint32(8).uint32(message.algorithm);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.length !== 0) {
      writer.uint32(24).uint32(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketChecksum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketChecksum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithm = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.length = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketChecksum {
    return {
      algorithm: isSet(object.algorithm) ? globalThis.Number(object.algorithm) : 0,
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
    };
  },

  toJSON(message: PacketChecksum): unknown {
    const obj: any = {};
    if (message.algorithm !== 0) {
      obj.algorithm = Math.round(message.algorithm);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketChecksum>, I>>(base?: I): PacketChecksum {
    return PacketChecksum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketChecksum>, I>>(object: I): PacketChecksum {
    const message = createBasePacketChecksum();
    message.algorithm = object.algorithm ?? 0;
    message.value = object.value ?? new Uint8Array(0);
    message.length = object.length ?? 0;
    return message;
  },
};

function createBasePacketTimestamp(): PacketTimestamp {
  return { seconds: 0, nanoseconds: 0 };
}

export const PacketTimestamp: MessageFns<PacketTimestamp> = {
  encode(message: PacketTimestamp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== 0) {
      writer.uint32(8).uint32(message.seconds);
    }
    if (message.nanoseconds !== 0) {
      writer.uint32(16).uint32(message.nanoseconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketTimestamp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seconds = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nanoseconds = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketTimestamp {
    return {
      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanoseconds: isSet(object.nanoseconds) ? globalThis.Number(object.nanoseconds) : 0,
    };
  },

  toJSON(message: PacketTimestamp): unknown {
    const obj: any = {};
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanoseconds !== 0) {
      obj.nanoseconds = Math.round(message.nanoseconds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketTimestamp>, I>>(base?: I): PacketTimestamp {
    return PacketTimestamp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketTimestamp>, I>>(object: I): PacketTimestamp {
    const message = createBasePacketTimestamp();
    message.seconds = object.seconds ?? 0;
    message.nanoseconds = object.nanoseconds ?? 0;
    return message;
  },
};

function createBasePacketSource(): PacketSource {
  return { ip: "", port: 0, mac: "" };
}

export const PacketSource: MessageFns<PacketSource> = {
  encode(message: PacketSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== "") {
      writer.uint32(10).string(message.ip);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.mac !== "") {
      writer.uint32(26).string(message.mac);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mac = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketSource {
    return {
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      mac: isSet(object.mac) ? globalThis.String(object.mac) : "",
    };
  },

  toJSON(message: PacketSource): unknown {
    const obj: any = {};
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.mac !== "") {
      obj.mac = message.mac;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketSource>, I>>(base?: I): PacketSource {
    return PacketSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketSource>, I>>(object: I): PacketSource {
    const message = createBasePacketSource();
    message.ip = object.ip ?? "";
    message.port = object.port ?? 0;
    message.mac = object.mac ?? "";
    return message;
  },
};

function createBasePacketDestination(): PacketDestination {
  return { ip: "", port: 0, mac: "" };
}

export const PacketDestination: MessageFns<PacketDestination> = {
  encode(message: PacketDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== "") {
      writer.uint32(10).string(message.ip);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.mac !== "") {
      writer.uint32(26).string(message.mac);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mac = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketDestination {
    return {
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      mac: isSet(object.mac) ? globalThis.String(object.mac) : "",
    };
  },

  toJSON(message: PacketDestination): unknown {
    const obj: any = {};
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.mac !== "") {
      obj.mac = message.mac;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketDestination>, I>>(base?: I): PacketDestination {
    return PacketDestination.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketDestination>, I>>(object: I): PacketDestination {
    const message = createBasePacketDestination();
    message.ip = object.ip ?? "";
    message.port = object.port ?? 0;
    message.mac = object.mac ?? "";
    return message;
  },
};

function createBasePacketProtocol(): PacketProtocol {
  return { name: "", version: 0, description: "" };
}

export const PacketProtocol: MessageFns<PacketProtocol> = {
  encode(message: PacketProtocol, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== 0) {
      writer.uint32(16).uint32(message.version);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketProtocol {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketProtocol();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketProtocol {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: PacketProtocol): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketProtocol>, I>>(base?: I): PacketProtocol {
    return PacketProtocol.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketProtocol>, I>>(object: I): PacketProtocol {
    const message = createBasePacketProtocol();
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBasePacketFlags(): PacketFlags {
  return { is_fragmented: false, is_encrypted: false, is_compressed: false, is_signed: false };
}

export const PacketFlags: MessageFns<PacketFlags> = {
  encode(message: PacketFlags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.is_fragmented !== false) {
      writer.uint32(8).bool(message.is_fragmented);
    }
    if (message.is_encrypted !== false) {
      writer.uint32(16).bool(message.is_encrypted);
    }
    if (message.is_compressed !== false) {
      writer.uint32(24).bool(message.is_compressed);
    }
    if (message.is_signed !== false) {
      writer.uint32(32).bool(message.is_signed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketFlags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketFlags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.is_fragmented = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.is_encrypted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.is_compressed = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.is_signed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketFlags {
    return {
      is_fragmented: isSet(object.is_fragmented) ? globalThis.Boolean(object.is_fragmented) : false,
      is_encrypted: isSet(object.is_encrypted) ? globalThis.Boolean(object.is_encrypted) : false,
      is_compressed: isSet(object.is_compressed) ? globalThis.Boolean(object.is_compressed) : false,
      is_signed: isSet(object.is_signed) ? globalThis.Boolean(object.is_signed) : false,
    };
  },

  toJSON(message: PacketFlags): unknown {
    const obj: any = {};
    if (message.is_fragmented !== false) {
      obj.is_fragmented = message.is_fragmented;
    }
    if (message.is_encrypted !== false) {
      obj.is_encrypted = message.is_encrypted;
    }
    if (message.is_compressed !== false) {
      obj.is_compressed = message.is_compressed;
    }
    if (message.is_signed !== false) {
      obj.is_signed = message.is_signed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketFlags>, I>>(base?: I): PacketFlags {
    return PacketFlags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketFlags>, I>>(object: I): PacketFlags {
    const message = createBasePacketFlags();
    message.is_fragmented = object.is_fragmented ?? false;
    message.is_encrypted = object.is_encrypted ?? false;
    message.is_compressed = object.is_compressed ?? false;
    message.is_signed = object.is_signed ?? false;
    return message;
  },
};

function createBasePacketVersion(): PacketVersion {
  return { major: 0, minor: 0, patch: 0, build: "" };
}

export const PacketVersion: MessageFns<PacketVersion> = {
  encode(message: PacketVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.major !== 0) {
      writer.uint32(8).uint32(message.major);
    }
    if (message.minor !== 0) {
      writer.uint32(16).uint32(message.minor);
    }
    if (message.patch !== 0) {
      writer.uint32(24).uint32(message.patch);
    }
    if (message.build !== "") {
      writer.uint32(34).string(message.build);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.major = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minor = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.patch = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.build = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketVersion {
    return {
      major: isSet(object.major) ? globalThis.Number(object.major) : 0,
      minor: isSet(object.minor) ? globalThis.Number(object.minor) : 0,
      patch: isSet(object.patch) ? globalThis.Number(object.patch) : 0,
      build: isSet(object.build) ? globalThis.String(object.build) : "",
    };
  },

  toJSON(message: PacketVersion): unknown {
    const obj: any = {};
    if (message.major !== 0) {
      obj.major = Math.round(message.major);
    }
    if (message.minor !== 0) {
      obj.minor = Math.round(message.minor);
    }
    if (message.patch !== 0) {
      obj.patch = Math.round(message.patch);
    }
    if (message.build !== "") {
      obj.build = message.build;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketVersion>, I>>(base?: I): PacketVersion {
    return PacketVersion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketVersion>, I>>(object: I): PacketVersion {
    const message = createBasePacketVersion();
    message.major = object.major ?? 0;
    message.minor = object.minor ?? 0;
    message.patch = object.patch ?? 0;
    message.build = object.build ?? "";
    return message;
  },
};

function createBasePacketError(): PacketError {
  return { code: 0, message: "", details: "" };
}

export const PacketError: MessageFns<PacketError> = {
  encode(message: PacketError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).uint32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketError {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: PacketError): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketError>, I>>(base?: I): PacketError {
    return PacketError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketError>, I>>(object: I): PacketError {
    const message = createBasePacketError();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.details = object.details ?? "";
    return message;
  },
};

function createBasePacketStatus(): PacketStatus {
  return { code: 0, message: "", details: "" };
}

export const PacketStatus: MessageFns<PacketStatus> = {
  encode(message: PacketStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).uint32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketStatus {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: PacketStatus): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketStatus>, I>>(base?: I): PacketStatus {
    return PacketStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketStatus>, I>>(object: I): PacketStatus {
    const message = createBasePacketStatus();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.details = object.details ?? "";
    return message;
  },
};

function createBasePacketResponse(): PacketResponse {
  return { code: 0, message: "", data: new Uint8Array(0), error: undefined, status: undefined };
}

export const PacketResponse: MessageFns<PacketResponse> = {
  encode(message: PacketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).uint32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.error !== undefined) {
      PacketError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      PacketStatus.encode(message.status, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = PacketError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = PacketStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketResponse {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      error: isSet(object.error) ? PacketError.fromJSON(object.error) : undefined,
      status: isSet(object.status) ? PacketStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: PacketResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.error !== undefined) {
      obj.error = PacketError.toJSON(message.error);
    }
    if (message.status !== undefined) {
      obj.status = PacketStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketResponse>, I>>(base?: I): PacketResponse {
    return PacketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketResponse>, I>>(object: I): PacketResponse {
    const message = createBasePacketResponse();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.error = (object.error !== undefined && object.error !== null)
      ? PacketError.fromPartial(object.error)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? PacketStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBasePacketRequest(): PacketRequest {
  return { id: 0, method: "", params: new Uint8Array(0), error: undefined, status: undefined };
}

export const PacketRequest: MessageFns<PacketRequest> = {
  encode(message: PacketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.method !== "") {
      writer.uint32(18).string(message.method);
    }
    if (message.params.length !== 0) {
      writer.uint32(26).bytes(message.params);
    }
    if (message.error !== undefined) {
      PacketError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      PacketStatus.encode(message.status, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.params = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = PacketError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = PacketStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      params: isSet(object.params) ? bytesFromBase64(object.params) : new Uint8Array(0),
      error: isSet(object.error) ? PacketError.fromJSON(object.error) : undefined,
      status: isSet(object.status) ? PacketStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: PacketRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.params.length !== 0) {
      obj.params = base64FromBytes(message.params);
    }
    if (message.error !== undefined) {
      obj.error = PacketError.toJSON(message.error);
    }
    if (message.status !== undefined) {
      obj.status = PacketStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketRequest>, I>>(base?: I): PacketRequest {
    return PacketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketRequest>, I>>(object: I): PacketRequest {
    const message = createBasePacketRequest();
    message.id = object.id ?? 0;
    message.method = object.method ?? "";
    message.params = object.params ?? new Uint8Array(0);
    message.error = (object.error !== undefined && object.error !== null)
      ? PacketError.fromPartial(object.error)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? PacketStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBasePacketAck(): PacketAck {
  return { id: 0, message: "", data: new Uint8Array(0), error: undefined, status: undefined };
}

export const PacketAck: MessageFns<PacketAck> = {
  encode(message: PacketAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.error !== undefined) {
      PacketError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      PacketStatus.encode(message.status, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = PacketError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = PacketStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketAck {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      error: isSet(object.error) ? PacketError.fromJSON(object.error) : undefined,
      status: isSet(object.status) ? PacketStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: PacketAck): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.error !== undefined) {
      obj.error = PacketError.toJSON(message.error);
    }
    if (message.status !== undefined) {
      obj.status = PacketStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketAck>, I>>(base?: I): PacketAck {
    return PacketAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketAck>, I>>(object: I): PacketAck {
    const message = createBasePacketAck();
    message.id = object.id ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.error = (object.error !== undefined && object.error !== null)
      ? PacketError.fromPartial(object.error)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? PacketStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBasePacketNack(): PacketNack {
  return { id: 0, message: "", data: new Uint8Array(0), error: undefined, status: undefined };
}

export const PacketNack: MessageFns<PacketNack> = {
  encode(message: PacketNack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.error !== undefined) {
      PacketError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      PacketStatus.encode(message.status, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketNack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketNack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = PacketError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = PacketStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketNack {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      error: isSet(object.error) ? PacketError.fromJSON(object.error) : undefined,
      status: isSet(object.status) ? PacketStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: PacketNack): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.error !== undefined) {
      obj.error = PacketError.toJSON(message.error);
    }
    if (message.status !== undefined) {
      obj.status = PacketStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketNack>, I>>(base?: I): PacketNack {
    return PacketNack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketNack>, I>>(object: I): PacketNack {
    const message = createBasePacketNack();
    message.id = object.id ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.error = (object.error !== undefined && object.error !== null)
      ? PacketError.fromPartial(object.error)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? PacketStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBasePacketPing(): PacketPing {
  return { id: 0, message: "", data: new Uint8Array(0), error: undefined, status: undefined };
}

export const PacketPing: MessageFns<PacketPing> = {
  encode(message: PacketPing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.error !== undefined) {
      PacketError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.status !== undefined) {
      PacketStatus.encode(message.status, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PacketPing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketPing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = PacketError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = PacketStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PacketPing {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      error: isSet(object.error) ? PacketError.fromJSON(object.error) : undefined,
      status: isSet(object.status) ? PacketStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: PacketPing): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.error !== undefined) {
      obj.error = PacketError.toJSON(message.error);
    }
    if (message.status !== undefined) {
      obj.status = PacketStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PacketPing>, I>>(base?: I): PacketPing {
    return PacketPing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PacketPing>, I>>(object: I): PacketPing {
    const message = createBasePacketPing();
    message.id = object.id ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.error = (object.error !== undefined && object.error !== null)
      ? PacketError.fromPartial(object.error)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? PacketStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseSerialPacketEvent(): SerialPacketEvent {
  return { id: "", packet: undefined };
}

export const SerialPacketEvent: MessageFns<SerialPacketEvent> = {
  encode(message: SerialPacketEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.packet !== undefined) {
      Packet.encode(message.packet, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SerialPacketEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSerialPacketEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.packet = Packet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SerialPacketEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      packet: isSet(object.packet) ? Packet.fromJSON(object.packet) : undefined,
    };
  },

  toJSON(message: SerialPacketEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.packet !== undefined) {
      obj.packet = Packet.toJSON(message.packet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SerialPacketEvent>, I>>(base?: I): SerialPacketEvent {
    return SerialPacketEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SerialPacketEvent>, I>>(object: I): SerialPacketEvent {
    const message = createBaseSerialPacketEvent();
    message.id = object.id ?? "";
    message.packet = (object.packet !== undefined && object.packet !== null)
      ? Packet.fromPartial(object.packet)
      : undefined;
    return message;
  },
};

function createBaseTargetPacket(): TargetPacket {
  return { target_id: 0, lat: 0, lon: 0, alt: 0, time: 0 };
}

export const TargetPacket: MessageFns<TargetPacket> = {
  encode(message: TargetPacket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target_id !== 0) {
      writer.uint32(8).uint32(message.target_id);
    }
    if (message.lat !== 0) {
      writer.uint32(17).double(message.lat);
    }
    if (message.lon !== 0) {
      writer.uint32(25).double(message.lon);
    }
    if (message.alt !== 0) {
      writer.uint32(33).double(message.alt);
    }
    if (message.time !== 0) {
      writer.uint32(41).double(message.time);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetPacket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.target_id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.lat = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lon = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.alt = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.time = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetPacket {
    return {
      target_id: isSet(object.target_id) ? globalThis.Number(object.target_id) : 0,
      lat: isSet(object.lat) ? globalThis.Number(object.lat) : 0,
      lon: isSet(object.lon) ? globalThis.Number(object.lon) : 0,
      alt: isSet(object.alt) ? globalThis.Number(object.alt) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
    };
  },

  toJSON(message: TargetPacket): unknown {
    const obj: any = {};
    if (message.target_id !== 0) {
      obj.target_id = Math.round(message.target_id);
    }
    if (message.lat !== 0) {
      obj.lat = message.lat;
    }
    if (message.lon !== 0) {
      obj.lon = message.lon;
    }
    if (message.alt !== 0) {
      obj.alt = message.alt;
    }
    if (message.time !== 0) {
      obj.time = message.time;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetPacket>, I>>(base?: I): TargetPacket {
    return TargetPacket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetPacket>, I>>(object: I): TargetPacket {
    const message = createBaseTargetPacket();
    message.target_id = object.target_id ?? 0;
    message.lat = object.lat ?? 0;
    message.lon = object.lon ?? 0;
    message.alt = object.alt ?? 0;
    message.time = object.time ?? 0;
    return message;
  },
};

function createBaseTargetPacketList(): TargetPacketList {
  return { packets: [] };
}

export const TargetPacketList: MessageFns<TargetPacketList> = {
  encode(message: TargetPacketList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packets) {
      TargetPacket.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetPacketList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetPacketList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packets.push(TargetPacket.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetPacketList {
    return {
      packets: globalThis.Array.isArray(object?.packets)
        ? object.packets.map((e: any) => TargetPacket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TargetPacketList): unknown {
    const obj: any = {};
    if (message.packets?.length) {
      obj.packets = message.packets.map((e) => TargetPacket.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetPacketList>, I>>(base?: I): TargetPacketList {
    return TargetPacketList.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetPacketList>, I>>(object: I): TargetPacketList {
    const message = createBaseTargetPacketList();
    message.packets = object.packets?.map((e) => TargetPacket.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
